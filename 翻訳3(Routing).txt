http://developer.couchbase.com/mobile/develop/guides/sync-gateway/sync-function-api-guide/routing/index.html

ルーティング
^^^^^^^^^^^^^

sync function APIはドキュメントをルーティングさせるために使用することが出来る様々な関数を備えています。ルーティング関数はドキュメントをチャネルに割り当て、ユーザーがチャネルにアクセス出来るようにします（チャネル内のドキュメントをユーザーにルーティングします）。

◯ノート
ルーティング変更はドキュメントのカレントリビジョンにひも付けられ、ドキュメントが更新されたら元に戻ります。”Sync function and document revisions" セクションをお読み下さい。

channel(name)
--------------------
channel関数は指定されたチャネルにドキュメントをルーティングします。一つ以上の引数を受け入れ、それぞれはチャネル名の文字列、もしくは文字列の配列でなければなりません。channel関数は、ドキュメント毎に、sync functionから全く呼ばれないこともあれば、複数回呼ばれることもあります。以下は全ての"published"なドキュメントを"public"チャネルにルーティングする例です。

function (doc, oldDoc) {
   if (doc.published) {
      channel ("public");
   } 
}

◯参考　便宜上、nullやundefinedの引数を用いてchannel関数を呼び出すことは問題ありません。単純に何もしません。これにより、doc.channelsが存在するかどうかを最初にチェックする必要なくchannel(doc.channels)のようなことが出来ます。

◯ノート  チャネルは事前に定義しておく必要はありません。チャネルはドキュメントがルーティングされると暗黙的に生成されます。

もしドキュメントが以前にチャネルにルーティングされていたが、現在のsync functionの呼び出し（更新リビジョンとして）がそのチャネルへルーティングしない場合、ドキュメントはチャネルから削除されます。これによりユーザーはそのドキュメントへのアクセスを失うことになるかもしれません。そうなった場合、次にユーザーのクライアントがgatewayから変更をプルした際は、"_removed":trueプロパティが入っただけのドキュメントのリビジョンを受け取ります。（当然、ドキュメントの以前のリビジョンは、クライアントのローカルデータベースが圧縮されるまではそこに留まります）

access (username, channelname)
-----------------------------------------------
access関数はチャネルへのアクセスを特定のユーザーへ付与します。sync functionから何度も呼ぶことが出来ます。

第一引数は文字列の配列にすることが出来ます。その場合、配列のそれぞれのユーザーがアクセスを与えられます。第二引数も文字列の配列にすることが出来ます。その場合、ユーザー（達）は配列のそれぞれのチャネルへのアクセスを付与されます。便宜上、どちらの引数もnullやundefinedでも問題ありません。その場合は何も起こりません。

もし、ユーザー名がrole:という接頭辞で始まる場合、名前の残りの部分はユーザー名ではなくロール名として解釈されます。その場合、その権限を持った全てのユーザーにその特定のチャネルへのアクセスが与えられます。

◯ノート
全てのアクティブなドキュメントによる全てのアクセスコールは効果的に結合されます。したがって、ユーザーアクセスのチャネルへの付与がどのドキュメントでなされても、そのユーザーはそのチャネルにアクセス出来ます。

◯注意
あるチャネルへのアクセスを取り消されたユーザーは、そのドキュメントに結びつくその他のチャネルへのアクセスもない場合、そのドキュメントへのアクセスを完全に失います。しかし、ユーザーのデバイスに既に同期されているドキュメントを、リプリケーターは現在は削除しません（それらのドキュメントに対する将来の変更は複製されませんが）。これはSync Gateway1.0の設計による制約で、将来は解消されるかもしれません。

以下のコードスニペットはいくつかの有効なaccess関数呼び出し方法です。

access ("jchris", "mtv");
access ("jchris", ["mtv", "mtv2", "vh1"]);
access (["snej", "jchris", "role:admin"], "vh1");
access (["snej", "jchris"], ["mtv", "mtv2", "vh1"]);
access (null, "hbo");  // 何も起こらない
access ("snej", null);  // 何も起こらない

以下は、ドキュメントにリスト化されている全てのユーザーに対してあるチャネルへのアクセスを付与するsync functionの例です。
function (doc, oldDoc) {
    if (doc.type == "chat_room") {
        // memberにこのドキュメントが管理するchatチャネルへのアクセスを付与する:
        	
        access (doc.members, doc.channel_name);
                            
        // このドキュメントをこのドキュメントが管理するチャネルへ入れる:
        channel (doc.channel_name);
    }
}


role (username, rolename)
-------------------------------------
role関数はユーザーにロールを付与し、間接的に、そのロールに付与されている全てのチャネルへのアクセスをユーザーに与えます。それはまた、もしドキュメントのある種の変更を検証するためにaccess関数がロールメンバーシップを必要としている場合、ユーザーのドキュメント改訂資格に影響を与えることになります。この使用法は、access関数と同様で、どちらのパラメータの値も文字列、文字列の配列、nullを取り得ます。もし値がnullの場合、関数呼び出しは機能しません。

access関数呼び出しとの整合性上、ロール名には常にrole:という接頭辞を用いなければなりません。もしロール名がこれにマッチしない場合、例外が送出されます。例としては：

role ("jchris", "role:admin");
role ("jchris", ["role:portlandians", "role:portlandians-owners"]);
role (["snej", "jchris", "traun"], "role:mobile");
role ("ed", null);  // 何も起こらない

◯ノート   ロールは、ユーザーのように、管理者によって明示的に生成されなければなりません。したがって、チャネル（単に命名されることで生成される）と違って、role関数の呼び出しで新しいロールを生成することは出来ません。存在しないロールは、エラーを引き起こすことはありませんが、ユーザーのアクセス権にも効力が生じません。ロールは事後的に作成することが出来ます。ロールが生成されると、事前に存在していたそれへの参照が有効になります。
